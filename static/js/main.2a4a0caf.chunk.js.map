{"version":3,"sources":["components/icon/Icon.js","components/IconWrapper.js","components/end-game-message/Message.js","components/Nav.js","components/Game.js","App.js","serviceWorker.js","index.js"],"names":["Icon","state","hover","style","margin","cursor","backgroundColor","toggleHover","_callee","regenerator_default","a","wrap","_context","prev","next","_this","setState","stop","setHover","_callee2","_context2","setHoverFalse","_callee3","_context3","setHoverTrue","_callee4","_context4","setColorOnHover","color","handleClick","_callee5","_context5","console","log","props","id","react_default","createElement","Fragment","react_fontawesome_index_es","onClick","this","Object","objectSpread","icon","onMouseEnter","onMouseLeave","spin","size","border","fixedWidth","React","Component","IconWrapper","Container_default","overflow","Jumbotron_default","renderIconCards","Message","Alert_default","textAlign","variant","show","message","styles","Nav","fluid","score","topScore","Button_default","handleResetGame","preProcessIconJSON","icons","map","clicked","Game","gameOver","gameWon","foundIndex","abrupt","findIndex","item","updateGameState","updateClicked","incrementScore","shuffleIcons","length","updateGameWon","uncheckAllIcons","uncheckedIcons","index","IconArray","array","arrayLength","i","randomIndex","temp","Math","floor","random","setTopScore","resetScore","won","isGameWon","determineVariant","determineMessage","icon_Icon","key","faviconName","className","components_Nav","end_game_message_Message","components_IconWrapper","library","add","faUser","faCheckSquare","faCoffee","faRocket","faFan","faTachometerAlt","faAdjust","faSkiing","faHamburger","App","components_Game","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2a4a0caf.chunk.js","sourcesContent":["import React from 'react'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\n\n\nclass Icon extends React.Component {\n\n  state = {\n    hover: false,\n    style: {\n      margin: '20px',\n      cursor: 'pointer',\n      backgroundColor: 'rgb(96, 125, 139)'\n    }\n  }\n\n  toggleHover = async () => {\n    await this.setState({ hover: !this.state.hover })\n  }\n\n  setHover = async (hover) => {\n    await this.setState({ hover })\n  }\n\n  setHoverFalse = async () => {\n    await this.setState({ hover: false })\n  }\n\n  setHoverTrue = async () => {\n    await this.setState({ hover: true })\n  }\n\n  setColorOnHover = () => {\n    let color;\n    if (this.state.hover) {\n      color = { color: '#ed1212' }\n    } else {\n      color = { color: '#000' }\n    }\n    return color\n  }\n\n  handleClick = async () => {\n    console.log(this.state.hover)\n    await this.setHover(false);\n    console.log(this.state.hover)\n    this.props.handleClick(this.props.id)\n  }\n\n  render() {\n\n    return (\n      <React.Fragment>\n        <FontAwesomeIcon\n          onClick={this.handleClick}\n          style={{ ...this.state.style, ...this.setColorOnHover() }}\n          icon={this.props.icon}\n          onMouseEnter={this.setHoverTrue} \n          onMouseLeave={this.setHoverFalse}\n          spin={this.state.hover}\n          size=\"10x\" \n          border \n          fixedWidth \n        />\n      </React.Fragment>\n    );\n  }\n}\n\n\nexport default Icon;","import React from 'react';\n\nimport Container from 'react-bootstrap/Container';\nimport Jumbotron from 'react-bootstrap/Jumbotron';\n\nconst IconWrapper = (props) => (\n    <Container style={{ 'overflow': true }}>\n      <Jumbotron >\n        {/* Icons */}\n        {props.renderIconCards()}\n      </Jumbotron>\n    </Container>\n  );\n\nexport default IconWrapper;\n","import React from 'react';\n\nimport Alert from 'react-bootstrap/Alert';\n\n\nconst Message = (props) => {\n  return (\n    <div>\n      <Alert\n        style={{ textAlign: 'center' }}\n        variant={props.variant}\n        show={props.show}>\n        {props.message}\n      </Alert>\n    </div>\n  );\n}\n\nexport default Message;","import React from 'react';\n\nimport Container from 'react-bootstrap/Container';\nimport Button from 'react-bootstrap/Button';\n\nconst styles = {\n  'textAlign': 'center',\n  'backgroundColor': 'rgb(48, 99, 127)',\n  color: 'white'\n};\n\nconst Nav = (props) => {\n\n  return (\n    <Container\n      fluid=\"true\"\n      style={styles}\n    >\n      <h1 >\n        Clicky Game\n        </h1>\n      <div id=\"score\">\n        Score:\n        {' '}\n        {props.score}\n        {' '}\n        | Top Score:\n        {' '}\n        {props.topScore}\n      </div>\n      <Button\n        variant=\"success\"\n        onClick={() => props.handleResetGame()}\n      >\n        Reset Game\n        </Button>\n    </Container>\n  );\n\n}\n\nexport default Nav;\n","import React from 'react';\r\n\r\nimport icons from './icon/icons.json';\r\nimport Icon from './icon/Icon';\r\nimport IconWrapper from './IconWrapper'\r\nimport Message from './end-game-message/Message';\r\nimport Nav from './Nav'\r\n\r\n\r\n// Add clicked property to each icon\r\nconst preProcessIconJSON = () => {\r\n  return icons.map(icon => {\r\n    icon.clicked = false;\r\n    return icon;\r\n  });\r\n}\r\n\r\nclass Game extends React.Component {\r\n\r\n  state = {\r\n    score: 0,\r\n    topScore: 0,\r\n    icons: preProcessIconJSON(),\r\n    gameOver: false,\r\n    gameWon: false,\r\n  }\r\n\r\n  // Shuffle icons on page load\r\n  // componentWillMount() {\r\n  //   this.shuffleIcons()\r\n  // }\r\n\r\n  // Main event handler on icon click\r\n  handleClick = async (id) => {\r\n    // Check if game over. Prevent icon click if true\r\n    if (this.state.gameOver) {\r\n      return\r\n    }\r\n    // Linear seach to find clicked item\r\n    const foundIndex = this.state.icons.findIndex(item => {\r\n      return item.id === id;\r\n    });\r\n    const foundItem = this.state.icons[foundIndex];\r\n\r\n    if (foundItem.clicked) { // Icon has already been clicked. Game over -> Loss\r\n      await this.updateGameState(true);\r\n    } else {\r\n      await this.updateClicked(true, foundIndex);\r\n      await this.incrementScore();\r\n      await this.shuffleIcons();\r\n      if (this.state.score === this.state.icons.length) { // All icons have been clicked only once. Game over -> Win\r\n        await this.updateGameState(true);\r\n        await this.updateGameWon(true);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Set clicked property to false for all icons\r\n  uncheckAllIcons = () => {\r\n    const uncheckedIcons = this.state.icons.map(icon => {\r\n      icon.clicked = false;\r\n      return icon;\r\n    });\r\n    this.setState({ icons: uncheckedIcons })\r\n  }\r\n\r\n  // Update clicked property for icon\r\n  updateClicked = (clicked, index) => {\r\n    const IconArray = this.state.icons;\r\n    IconArray[index].clicked = clicked;\r\n    this.setState({ icons: IconArray })\r\n  }\r\n\r\n  shuffleIcons = async () => {\r\n    const array = this.state.icons;\r\n    const arrayLength = array.length;\r\n\r\n    for (let i = arrayLength - 1; i > 0; i--) {\r\n      const randomIndex = Math.floor(Math.random() * (i + 1));\r\n      const temp = array[randomIndex];\r\n      array[randomIndex] = array[i];\r\n      array[i] = temp;\r\n    }\r\n    await this.setState({ icons: array })\r\n  };\r\n\r\n  incrementScore = async () => {\r\n    await this.setState({ score: this.state.score + 1 })\r\n    await this.setTopScore();\r\n  }\r\n\r\n  resetScore = () => {\r\n    this.setState({ score: 0 })\r\n  }\r\n\r\n  setTopScore = async () => {\r\n    if (this.state.score > this.state.topScore) {\r\n      await this.setState({ topScore: this.state.score });\r\n    }\r\n  }\r\n\r\n  handleResetGame = async () => {\r\n    await this.updateGameState(false);\r\n    await this.updateGameWon(false);\r\n    await this.resetScore();\r\n    await this.shuffleIcons();\r\n    await this.uncheckAllIcons()\r\n  }\r\n\r\n  updateGameState = (state) => {\r\n    this.setState({ gameOver: state })\r\n  }\r\n\r\n  updateGameWon = (won) => {\r\n    this.setState({ gameWon: won })\r\n  }\r\n\r\n  isGameWon = () => {\r\n    return this.state.gameOver && this.state.gameWon;\r\n  }\r\n\r\n  determineVariant = () => {\r\n    if (this.isGameWon()) {\r\n      return 'success';\r\n    }\r\n    return 'danger';\r\n  }\r\n\r\n  determineMessage = () => {\r\n    if (this.isGameWon()) {\r\n      return 'You Win!';\r\n    }\r\n    return 'You Lose!';\r\n  }\r\n\r\n  renderIconCards = () => {\r\n    return this.state.icons.map(icon =>  (\r\n        <Icon\r\n          key={icon.id}\r\n          id={icon.id}\r\n          icon={icon.faviconName}\r\n          handleClick={this.handleClick}\r\n          clicked={icon.clicked}>\r\n        </Icon>\r\n      )\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\" style={{ overflow: true }}>\r\n        <Nav\r\n          score={this.state.score}\r\n          topScore={this.state.topScore}\r\n          handleResetGame={this.handleResetGame}\r\n        />\r\n\r\n        {/* Game over message */}\r\n        <Message\r\n          show={this.state.gameOver}\r\n          variant={this.determineVariant()}\r\n          message={this.determineMessage()}>\r\n        </Message>\r\n\r\n        {/* Icons */}\r\n        <IconWrapper renderIconCards={this.renderIconCards} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;\r\n","import React from 'react';\n\n// Fontawesome imports\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { faUser, faRocket, faFan, faTachometerAlt } from \"@fortawesome/free-solid-svg-icons\";\nimport { faCheckSquare, faCoffee, faAdjust, faSkiing, faHamburger } from '@fortawesome/free-solid-svg-icons'\n\n// Bootstrap imports\nimport 'bootstrap/dist/css/bootstrap.css';\n\nimport Game from './components/Game';\n\n// Add Fontawesome icons to library\nlibrary.add(faUser, faCheckSquare, faCoffee, faRocket, faFan, faTachometerAlt, faAdjust, faSkiing, faHamburger);\n\nconst App = () => (\n  <Game />\n);\n\n\nexport default App;\n","/*\n * This optional code is used to register a service worker.\n * register() is not called by default.\n */\n\n/*\n * This lets the app load faster on subsequent visits in production, and gives\n * it offline capabilities. However, it also means that developers (and users)\n * will only see deployed updates on subsequent visits to a page, after all the\n * existing tabs open on the page have been closed, since previously cached\n * resources are updated in the background.\n */\n\n/*\n * To learn more about the benefits of this model and instructions on how to\n * opt-in, read https://bit.ly/CRA-PWA\n */\n\nconst isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\nexport function register (config) {\n\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n\n      /*\n       * Our service worker won't work if PUBLIC_URL is on a different origin\n       * from what our page is served on. This might happen if a CDN is used to\n       * serve assets; see https://github.com/facebook/create-react-app/issues/2374\n       */\n      return;\n\n    }\n\n    window.addEventListener('load', () => {\n\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        /*\n         * Add some additional logging to localhost, pointing developers to the\n         * service worker/PWA documentation.\n         */\n        navigator.serviceWorker.ready.then(() => {\n\n          console.log('This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA');\n\n        });\n\n      } else {\n\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n\n      }\n\n    });\n\n  }\n\n}\n\nfunction registerValidSW (swUrl, config) {\n\n  navigator.serviceWorker.\n    register(swUrl).\n    then((registration) => {\n\n      registration.onupdatefound = () => {\n\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n\n          return;\n\n        }\n        installingWorker.onstatechange = () => {\n\n          if (installingWorker.state === 'installed') {\n\n            if (navigator.serviceWorker.controller) {\n\n              /*\n               * At this point, the updated precached content has been fetched,\n               * but the previous service worker will still serve the older\n               * content until all client tabs are closed.\n               */\n              console.log('New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.');\n\n              // Execute callback\n              if (config && config.onUpdate) {\n\n                config.onUpdate(registration);\n\n              }\n\n            } else {\n\n              /*\n               * At this point, everything has been precached.\n               * It's the perfect time to display a\n               * \"Content is cached for offline use.\" message.\n               */\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n\n                config.onSuccess(registration);\n\n              }\n\n            }\n\n          }\n\n        };\n\n      };\n\n    }).\n    catch((error) => {\n\n      console.error('Error during service worker registration:', error);\n\n    });\n\n}\n\nfunction checkValidServiceWorker (swUrl, config) {\n\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl).\n    then((response) => {\n\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        contentType != null && contentType.indexOf('javascript') === -1\n      ) {\n\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n\n          registration.unregister().then(() => {\n\n            window.location.reload();\n\n          });\n\n        });\n\n      } else {\n\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n\n      }\n\n    }).\n    catch(() => {\n\n      console.log('No internet connection found. App is running in offline mode.');\n\n    });\n\n}\n\nexport function unregister () {\n\n  if ('serviceWorker' in navigator) {\n\n    navigator.serviceWorker.ready.then((registration) => {\n\n      registration.unregister();\n\n    });\n\n  }\n\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n/*\n * If you want your app to work offline and load faster, you can change\n * unregister() to register() below. Note this comes with some pitfalls.\n * Learn more about service workers: https://bit.ly/CRA-PWA\n */\nserviceWorker.unregister();\n"],"sourceRoot":""}